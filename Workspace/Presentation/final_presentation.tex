\documentclass{../Common/Structure/pdf_presentation}
%
\usepackage{pgfgantt}

%
\title{Final Presentation}
%
\pdfinfo{
	/Author (Marco Redaelli;Francesci Zanoli)
	/Title  (Software Engineering 2 - Final Presentation)
	/CreationDate (D:20170228090000)
	/Subject (Final Presentation)
	/Keywords (Final;Presentation;Software;Engineering)
}
%
\AtBeginSubsection[]
{
	\begin{frame}<beamer>{Outline}
		\tableofcontents[currentsection,currentsubsection]
	\end{frame}
}
%
\begin{document}
	\titleToc{}
	\section{Introduction}
	\begin{frame}{Introduction}
		The project we have been assigned is called \PowerEnJoy{} and it is a complex software system that should implement a
		car sharing service. In order to rationalize, clarify, and put in structured and standardized documents all the
		relevant concepts and informations, we designed and delivered several documents such as the \textbf{RASD}, the  \textbf{DD},
		the \textbf{ITPD}, and the \textbf{PPD}. These slides will only present an overview of the concepts thoroughly
		described in the above mentioned documents.
	\end{frame}
	\begin{frame}{Tools}
		We composed the documents we had to using some tools such as:
		\begin{itemize}
			\itemBold{TexStudio} to compile \LaTeX{} document.
			\itemBold{StarUML} to draw UML diagrams.
			\itemBold{Alloy Analizer 4.2} to checking model consistency.
			\itemBold{Draw.io} to build mockups.
			\itemBold{GitHub} for storing the project.
			\itemBold{Skype} for team collaboration
		\end{itemize}
	\end{frame}
	\section{Requirement Analysis and Specification}
	\subsection{Overview}
	\begin{frame}{Overview}
		The aim of the software is to provide a new digital management system for car-sharing service that exclusively uses
		electrical cars. It can be applied to different small and big city and even in a large urban area.
	\end{frame}
	\begin{frame}{Goals}
		This new service pretends to achieve various goals, such as:
		\begin{itemize}
			\itemBold{G4} Allow user logged in to book a car in a certain location.
			\itemBold{G6} A user who request a rent can abort the process when ever he/she wants.
			\itemBold{G9} A non registered users can only register once to the service.
			\itemBold{G10} A user can get discount or overtaxes from his/her last rent.
		\end{itemize}
	\end{frame}
	\begin{frame}{Actors - Users, Cars and Customer Service}
		Below are listed the four main actors that will interact with the application once deployed:
		\begin{itemize}
			\itemBold{Registered User} A person who subscribed to the system and can access to all functionalities of the application.
			\itemBold{Visitors} A person that needs to move from a position	to another one among the city and wants to use \PowerEnJoy{} in order to do so, but has not registered yet to the service.
			\itemBold{Car} The car reserved / rented / Parked that communicates with the system.
			\itemBold{External Customer Service} A team that provide technical support in case of problems related to the car.
		\end{itemize}
	\end{frame}
	\begin{frame}{Product Perspective}
		Our \PowerEnJoy{} is a \textbf{completely new product}, not based on previous ones.\par
		It relies on \textbf{location data} received via \textbf{Internet} from each user application and car system: all the involved smartphones already have a \textbf{GPS antenna} installed inside, that communicates their position to the service.\par
		Being a partially \textbf{distributed application}, \PowerEnJoy{} requires a fully operative \textbf{Internet} connection in order to work properly, both on server and client side: \textbf{no service is intended to be provided offline}.
	\end{frame}
	\begin{frame}{More on Product Perspective}
		All the data generated by this software are stored in a database, accordingly to current normative and laws about privacy and personal data management.\par
		In addition, several \textbf{API}s are provided in order to allow further improvements and expansions of the software: for instance, the payment will be managed from an external entity (we supposed \textbf{PayPal}) and the map will be provided by \textbf{Google}.
	\end{frame}
	\subsection{UML Diagrams}
	\begin{frame}{UML Diagrams}
		We provided a variety of UML diagrams, each type having a different purpose.
		\begin{itemize}
			\item\textbf{UML Use Case} %Shows the identified \textbf{use cases} in relation with the \textbf{involved actors}.
			\item\textbf{UML Sequence Diagram} %Indicates, for a given \textbf{use case}, the \textbf{interaction} between the \textbf{actors involved} and the \textbf{system}.
			\item\textbf{UML Class diagram} %Points out the different \textbf{software entities} involved in the application and the \textbf{relationships} between them.
		\end{itemize}
	\end{frame}
	\begin{frame}{UML Use Case Diagram}
		This is perhaps the most useful diagram that can be designed in the early phase of the development of a software project.
		\showPercentImageNoCaption{../RASD/Resources/UseCaseModel.png}{0.7}
	\end{frame}
	\begin{frame}{UML Class Diagram}
		Furthermore we designed a class diagram for an early evaluation of the basic software components that consists in a sort of \textbf{Model} for \PowerEnJoy{}.
		\showPercentImageNoCaption{../RASD/Resources/UML.png}{0.5}
	\end{frame}
	\subsection{Alloy}
	\begin{frame}{Alloy}
		Alongside the \textbf{UML Class Diagram} we built \textbf{Alloy Models} using the \textbf{Alloy} modeling language with the help of \textbf{Alloy Analyzer 4.2}.\par
		The tool didn't find a proof of the inconsistency of our \textbf{Alloy Models}, and that along with the \textbf{Automatic Generation} (and \textbf{Manual Verification}) of interesting worlds, made us aware of the \textbf{Consistency} of those \textbf{Models} within a reasonable level of confidence.
	\end{frame}
	\begin{frame}{Alloy Simple World}
		Here is an example of one among the \textbf{simplest world} we generated and double checked using both \textbf{Alloy Analyzer 4.2} and \textbf{manual checking}.
		\showPercentImageNoCaptionRotate{../RASD/Resources/SimpleWorld.pdf}{0.5}{90}
	\end{frame}
	\section{Design}
	\subsection{Architectural Design}
	\begin{frame}{High level components and their interaction}
		The system is composed of many \textbf{distributed} components: those will communicate with a \textbf{Client-Server} style and through \textbf{Point to Point} messaging system.
		\begin{itemize}
			\item The \textbf{Client-Server} style is used to give the many Clients connected to the Server the opportunity of sending different requests (e.g. a \textbf{Car Reservation} or \textbf{Open Car Request}).
			\item The \textbf{Point to Point} bidirectional communication channel is made necessary to enable the Server the delivery of various messages and requests to the Clients and the Car:
			\begin{itemize}
				\item Generic notifications
				\item Service messages
				\item Internal message to the car as Open or Check the status
			\end{itemize}
		\end{itemize}
	\end{frame}
	\begin{frame}{Layer}
		The selected software architecture follows the principles of the \textbf{Model View Controller} architectural pattern, therefore three main software components have been identified and those are:
		\begin{itemize}
			\item The \textbf{View}, the user application View that is designed to perform comfortable user expirience
		\end{itemize}
	\end{frame}
	\begin{frame}{Layer}
		\begin{itemize}
			\item The \textbf{Controller}, in charge of leading the communication between views and process either \textbf{synchronous responses} or \textbf{asynchronous events}.
			\item The \textbf{Model} that guarantees a high level interface to store and manage all the \PowerEnJoy{} relevant data and an abstraction of \textbf{Relational Database} in a software component that is in direct connection with the \textbf{Controller}
		\end{itemize}
	\end{frame}
	\begin{frame}{Tiers}
		The selected software architecture follows the principles of the \textbf{3-Tiers} architecture. Therefore our structure expands this concept by adding 1 additional tiers to interact with the external word\par
		In particular the tiers are:
		\begin{itemize}
			\item The \textbf{Client}, the mobile application designed and projected
			\item The \textbf{Application Server}, the main core of the system that include \textbf{Controller} and \textbf{Model} into it
			\item The \textbf{DB Server}, the data storage of the \PowerEnJoy{}' data.
			\item The \textbf{Car System}, that is the interface between the physical system and the software, furnished by sensor and display in order to comunicate with the user.
		\end{itemize}
	\end{frame}
	\begin{frame}{Component View}
		Several components has been designed to provide all the functionalities needed for \PowerEnJoy{} to work.
		Many subsystems have been identified:
		\begin{itemize}
			\item Ride Manager,Bill Manager,Zone Manager...
			\item Database ...
			\item External API ...
		\end{itemize}
	\end{frame}
	\begin{frame}{Component View - UML Component Diagram}
		\showPercentImageNoCaption{../DD/Resources/ComponentDiagram.png}{1}
	\end{frame}
	\begin{frame}{Deployment View}
			The best way found to deploy the software components identified, is to consider 4 different nodes (7 if considering the Google Server and the
			PayPal server) that correspond with the \textbf{Tiers} with in addiction the \textbf{External Extentions}
	\end{frame}
	\begin{frame}{Deployment View - UML Deployment Diagram}
		The following diagram shows how \textbf{software components} are mapped into the \textbf{physical system}.
		\showPercentImageNoCaption{../DD/Resources/DeploymentDiagram.png}{0.6}
	\end{frame}
	\begin{frame}{Runtime View}
		Here are proposed some of the most meaningful \textbf{UML Sequence Diagrams} with respect to show how software components interacts.
		The chosen functionalities are:
		\begin{itemize}
			\item Find a FreeCar
			\item Make a Reservation
		\end{itemize}
		There are other functionalities whose \textbf{UML Sequence Diagram} is not reported here for space and time constraints:
	\end{frame}
	\begin{frame}{Find a FreeCar}
		\showPercentImageNoCaption{../DD/Resources/FindFreeCarSequence.png}{0.6}
	\end{frame}
	\begin{frame}{Make a Reservation}
		\showPercentImageNoCaption{../DD/Resources/ReserveSequence.png}{0.6}
	\end{frame}
	\begin{frame}{Other design decisions - Car System}
		We assumed to a Car system that can completly control any important aspect of the car as:
		\begin{itemize}
			\itemBold{Open the car}
			\itemBold{Count the Passenger}
			\itemBold{Display Message thought a navigator' LCD}
			\itemBold{Check car' position}
			\item ....
		\end{itemize}
	\end{frame}

	\subsection{User Interface Design}
	\begin{frame}{GUI Design}
		In this section we provide the \textbf{most important and meaningful mockups} for every class of screens we have designed.
	\end{frame}
	\begin{frame}{Car Info Mockups}
		\showPercentImageNoCaption{../DD/Resources/CarInfo.png}{0.3}
	\end{frame}
	\begin{frame}{Reservation Mockups}
		\showPercentImageNoCaption{../DD/Resources/Reservation.png}{0.3}
	\end{frame}
	\begin{frame}{End Rent Mockups}
		\showPercentImageNoCaption{../DD/Resources/EndRent.png}{0.3}
	\end{frame}
	\section{Integration Test Plan}
	\subsection{Overview}
	\begin{frame}{Scope and Approach}
		This project phase is highly based on the \textbf{Design} one. \\
		\medskip
		We will clearly state the order in which the software components identified in the \textbf{Component View} of the \textbf{Design} part have to be integrated one with each other in order to guarantee a well tested final software.\\
		\medskip
		The \textbf{bottom-up integration testing approach} has been chosen, because for a medium sized project like \PowerEnJoy{}, it is best to proceed step by step in a careful yet coherent integration strategy.\\
	\end{frame}
	\begin{frame}{Entry Criteria}
		Before starting the integration testing of any software component that has been designed for \PowerEnJoy{} system, few points have to be underlined:
		\begin{itemize}
			 \item The \textbf{internal functions} of the considered component must be \textbf{unit tested} using an appropriate framework.
			 \item We suppose that \textbf{Google Maps API and PayPal API} are well tested by \textbf{Google and PayPal} and thus we can use them without testing any
			 further.
		\end{itemize}
	\end{frame}
	\begin{frame}{Integration Testing Strategy}
		We have considered all the \textbf{Subsystems}. and we had divided into 3 different categories, in particular we divided the system in part based on the drivers' number. Trying to minimize the number of drivers to use in a \textbf{bottom-up} strategy.\\
	\end{frame}
	\subsection{Integration Sequence Diagrams}
	\begin{frame}{Convention adopted - Blocks}
		\begin{itemize}
			\itemBold{Green} This block is not dependent on any lower level component in \PowerEnJoy{} and therefore it is integrated as a starting point in the current diagram.
			\itemBold{Red} This block is going to use some Drivers in order to perform a complete test on all its functionalities
			\itemBold{Yellow} This block is going to be tested without Drivers because it's at the end of the process.
			\itemBold{Blue}	This block will be not tested.
		\end{itemize}
	\end{frame}
	\begin{frame}{System Integration Sequence}
		\showPercentImageNoCaption{../ITPD/Diagrams/SubsystemsIntegrationDiagram.png}{0.75}
	\end{frame}
	\begin{frame}{Subsytem Integration Sequence}
		\showPercentImageNoCaption{../ITPD/Diagrams/SoftwareIntegrationDiagram.png}{0.75}
	\end{frame}
	\begin{frame}{Program Drivers And Data Required}
		In conclusion there is the need for some sample data to be in the \textbf{Database} and some sample \textbf{GPS data} are needed.
	\end{frame}
	\section{Project Plan}
	\subsection{Plan Contents}
	\begin{frame}{Plan Contents}
		The \textbf{Project Plan} consists in tables, \textbf{Gantt diagrams}, charts and natural language descriptions of the planning, scheduling and management of \PowerEnJoy{} development. \\
		\medskip
		In order to estimate the project effort, we followed the assumption that the \textbf{dimension of the software} can be characterized by correlating \textbf{the kind of functionalities offered} with \textbf{the source lines of code (SLOC) of the software itself}
	\end{frame}
	\subsection{Cost Models}
	\begin{frame}{Function Points Approach}
		The \textbf{Function Points approach}, defined in 1975 by Allan Albrecht:
		\begin{itemize}
			\item Consists in a technique to assess the effort needed to design and develop custom software applications.
			\item Correlates the kind of functionalities offered with the source lines of code of the software itself.
		\end{itemize}
	\end{frame}
	\begin{frame}{Function Points Approach}
		This technique consists in combining the following program characteristics to obtain a final result:
		\begin{itemize}
			\item \textbf{Internal Logic Files}% Data used and managed by the application
			\item \textbf{External Logic Files} %Data used by the application but generated and maintained by other applications.
			\item \textbf{External Input} %Elementary operations to elaborate data coming from the external environment.
			\item \textbf{External Output} %Elementary operations that generate data for the external environment, and they usually include the elaboration of data
			\item \textbf{External Inquiry} %Elementary operations that involve input and output, without significant elaboration of data.
		\end{itemize}
	\end{frame}
	\begin{frame}{Function Points Summary}
		All the calculated $FP_{i}$ sums up to $FP$, which is the total Function Points value:
		\begin{equation*}
			\begin{aligned}
				&	FP
				& & = FP_{ILF} + FP_{ELF} + FP_{EI} + FP_{EO} + FP_{EIQ}\\
				&&& = 80 + 10 + 35 + 16 + 8\\
				&&& = 149\\
			\end{aligned}
		\end{equation*}
	\end{frame}
	\begin{frame}{COCOMO II - Parameters}
		\showPercentImageNoCaption{../PPD/Resources/Cocomo_2.png}{0.9}
	\end{frame}
	\begin{frame}{COCOMO II - Results}
		\showPercentImageNoCaption{../PPD/Resources/Cocomo_1.png}{0.75}
	\end{frame}
	\subsection{Tasks Scheduling}
	\begin{frame}{Tasks}
		\begin{tabulary}{\linewidth\tymin=70pt}{Y{2cm}|Y{4cm}|Y{2.25cm}}
			\textbf{Task} & \textbf{Description} & \textbf{Completed?}\\ \hline
			T1a & RASD - Writing & Yes \\ \hline
			T1b & RASD - Presentation & Yes \\ \hline
			T2a & DD - Writing & Yes \\ \hline
			T2b & DD - Presentation & Yes \\ \hline
			T3a & ITPD - Writing & Yes \\ \hline
			T3b & ITPD - Presentation & Yes \\ \hline
			T4a & PPD - Writing & Yes \\ \hline
			T4b & Final Presentation & Yes \\ \hline
			T5 & Implementation & No \\ \hline
			T6 & Unit Testing & No \\ \hline
			T7 & Integration Testing & No \\ \hline
			T8 & System Testing & No \\ \hline
			T9 & User Acceptance - Alpha Testing & No \\ \hline
			T10 & User Acceptance - Beta Testing & No \\ \hline
			T11 & Release To Market & No \\
		\end{tabulary}
	\end{frame}
	\begin{frame}{Gantt Diagram}
		\showPercentImageNoCaption{../PPD/Resources/GanttDiagram.png}{0.75}
	\end{frame}
	\begin{frame}{End}
		Thank you for your attention.
	\end{frame}
	\begin{frame}{Appendix- Next version}
		We could also keep updating the system.
		For example we could add an \textbf{Admin workstation} in order to allow the owner to have a control on the data and
		to maintain the system by itself.
	\end{frame}
	\begin{frame}{Appendix- Algorithm}
		\showPercentImageNoCaption{./Resources/algo.png}{0.7}
	\end{frame}
\end{document}
